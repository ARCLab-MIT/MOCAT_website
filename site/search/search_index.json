{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MIT Orbital Capacity Assesment Tool","text":""},{"location":"#what-is-mocat","title":"What is MOCAT?","text":"<p>Risk-based capacity, or carrying-capacity, looks at the quantity and configuration of objects that can be placed subject to various constraints. ARCLab is developing the MIT Orbital Capacity Assessment Tool (MOCAT). MOCAT is a suite of MATLAB models to assess the evolution of Low Earth Orbit over long periods of time under different assumptions. There are currently two main portions of MOCAT, MOCAT Monte Carlo (MOCAT-MC), which uses super-computing to evaluate environmental trends in higher fidelity, and MOCAT Source Sink Evolutionary Model (MOCAT-SSEM), which uses a lower fidelity modeling approach capable of running on a personal computer in seconds to minutes.</p> <p>Both tools exist with a basic level of functionality. MOCAT-MC runs are regularly being performed on MIT\u2019s supercomputer to explore a variety of potential future scenarios and optimize the codebase. Runs show good agreement with outputs of the European Space Agency\u2019s DELTA tool.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Richard Linares - Faculty Advisor</li> <li>Di Wu - Lab Member</li> <li>Daniel Jang - Lab Member</li> </ul>"},{"location":"#papers","title":"Papers","text":"<ol> <li>Jang, Daniel &amp; D'Ambrosio, Andrea &amp; Lifson, Miles &amp; Pasiecznik, Celina &amp; Linares, Richard. (2022). Stability of the LEO Environment as a Dynamical System. </li> <li>Jang, Daniel &amp; Gusmini, Davide &amp; Siew, Peng Mun &amp; D'Ambrosio, Andrea &amp; Servadio, Simone &amp; Machuca, Pablo &amp; Linares, Richard. (2023). Monte Carlo Methods to Model the Evolution of the Low Earth Orbit Population. </li> <li>Hugh G. Lewis. (2020). Understanding long-term orbital debris population dynamics,</li> </ol>"},{"location":"api/","title":"API Documentation","text":"<p>MOCAT Monte Carlo set up function and main function:</p> <pre><code>    function cfgMC = setup_MCconfig(rngseed,ICfile)\n    % Setting up scenario:\n    % Inputs:\n    %       rngseed: a random seed\n    %       ICfile: initial conditions file containing initial condition matrix \n    %       which follows standard mat_sats (matlab satellite) matrix form\n    % idx_a = 1; idx_ecco = 2; idx_inclo = 3; idx_nodeo = 4; idx_argpo = 5; idx_mo = 6; idx_bstar = 7; idx_mass = 8; idx_radius = 9;\n    % idx_error = 10; idx_controlled = 11; idx_a_desired = 12; idx_missionlife = 13; idx_constel = 14; idx_date_created = 15; idx_launch_date = 16;\n    % idx_r = [17 18 19]; idx_v = [20 21 22]; idx_objectclass = 23; idx_ID = 24;\n    % Outputs: cfgMC (configure MC) struct for function main_mc.m\n    % Di Wu, 10/17/2023\n    %---------------------------------------------------------------------\n    % other standard MIT setup:\n    % No explosions, No collision avoidance\n    % 8 year payload lifetime, 95% PMD\n    % Launches: 2001-2009 repeated specified by launchRepeatYrs (~ 75 / yr via Fig 2.14 in ESA 2022)\n    %---------------------------------------------------------------------\n\n    % constants for MC configure\n    cfgMC_constants;\n\n    % SCENARIO PARAMETERS\n    cfgMC.PMD = 0.95;                   % POST MISSION DISPOSAL (active sats only); ESA: 55% RB, 40% PL, 90% Const\n    cfgMC.alph = 0.01;                  % COLLISION AVOIDANCE failure probability with one sat active\n    cfgMC.alph_a = 0;                   % COLLISION AVOIDANCE failure probability with both sat active\n    cfgMC.orbtol = 5;                   % orbit control tolerance for controlled satellites [km]\n    cfgMC.step_control = 2;             % orbit control tolerance checking timesteps\n    cfgMC.P_frag = 0;                   % EXPLOSION PROBABILITY per day of Rocket Body Fragmentation (if P_frag=0, explosions are not considered!)\n    cfgMC.P_frag_cutoff = 18;           % EXPLOSION PROBABILITY age at which objects don't explode.\n    cfgMC.altitude_limit_low = 200;     % SHELL lower limit of altitude [km] \n    cfgMC.altitude_limit_up = 2000;     % SHELL upper limit of altitude [km]\n    cfgMC.missionlifetime = 8;          % PAYLOADS operational life [years]\n\n    % SET PROPAGATION TIMES\n    t0_prop = 0;                                    % initial PROPAGATION time [min]\n    nyears = 10;                                    % length of PROPAGATION [years]\n    tf_prop = cfgMC.YEAR2MIN * nyears;              % length of PROPAGATION [min]\n    cfgMC.dt_days = 5;                              % CUBE METHOD and PROPAGATION sampling time [days]\n    DeltaT = cfgMC.dt_days*cfgMC.DAY2MIN;           % CUBE METHOD and PROPAGATION sampling time [min]\n    cfgMC.tsince = t0_prop:DeltaT:t0_prop+tf_prop;  % PROPAGATION time list\n    cfgMC.n_time = length(cfgMC.tsince);            % length of PROPAGATION time list\n\n    % LAUNCHES\n    Simulation = 'TLE';                     % 'TLE'\n    launch_model = 'no_launch';             % random, matsat, no_launch, data, Somma      \n    % 0: random launch via poisson distribution (see initSim below)\n    % 1: repeat launches between years X and Y (ESA style launch)\n\n    cfgMC.launchRepeatYrs = [2018,2022];    % Min/max year of obj to repeatedly launch (inclusive)\n                                            % Only used if TLElaunchRepeat == 1\n    cfgMC.launchRepeatSmooth = 0;           % [0/1] average out the above so yearly launch rate remains the same\n\n    % PREPARE INITIAL CONDITION POPULATION\n    fillin_physical_parameters;             % Fill in missing satellite physical parameters\n\n    %-----------------------\n    % Initialize INITIAL CONDITION POPULATION and LAUNCHES\n    cfgMC = initSim(cfgMC, Simulation, launch_model, ICfile);   \n    %-----------------------\n    % Initialize SHELL information specified by paramSSEM\n    paramSSEM.N_shell = 36;\n    paramSSEM.h_min = cfgMC.altitude_limit_low; \n    paramSSEM.h_max = cfgMC.altitude_limit_up;\n    paramSSEM.R02 = linspace(paramSSEM.h_min,paramSSEM.h_max,paramSSEM.N_shell+1); % R02 is the boundary list of all shells\n    paramSSEM.re = radiusearthkm; % km\n    cfgMC.paramSSEM = paramSSEM;\n    %------------------------\n\n    % PROPAGATOR\n    cfgMC.use_sgp4 = false;             % only 'false' is currently supported\n\n    % COLLISION\n    cfgMC.skipCollisions = 0;           % if 1, collision step is skipped in main_mc\n    cfgMC.max_frag = inf;\n\n    % CUBE METHOD\n    cfgMC.CUBE_RES = 50;                    % CUBE METHOD resolution for the size of cube\n    cfgMC.collision_alt_limit = 45000;      % Ignoring satellites above 45000km for collision evaluation\n\n    % ATMOSPHERE\n    fillin_atmosphere;                  % Fill in atmosphere setup\n\n    % Animation \n    cfgMC.animation = 'no';             % yes to live plot of the simulation, no otherwise\n\n    % Save output file\n    cfgMC.save_diaryName = '';          % save commandline output text to this output;  to skip saving: ''\n    cfgMC.save_output_file = 0;         \n        % 0: don't save;\n        % 1: save entire workspace\n        % 2: sats_info, config, params\n        % 3: summary (S_MC, N_MC, ...), config\n        % 4: summary and collision stats (frag_info)\n        % 5: just collision stats (frag_info)\n        % 10: save mat_sats every 'saveMSnTimesteps' timesteps\n        %       savevars = {'MCconfig','param','paramSSEM','matsatsperN'};\n        % 11: flag10 &amp; frag_info5 (collision stats per timestep)\n        %      frag_info5: p1 mass, p2 mass (0.1 kg), alt10km, debAn, debBn [Mx5] uint16\n    cfgMC.saveMSnTimesteps = 146;  % every ~2 yrs\n\n    foldername = 'LRCI_1year';\n    % Check if the folder already exists\n    if exist(\"foldername\", 'dir') == 0     % Folder does not exist, so create it\n        mkdir(foldername);\n    end\n    filename_save = sprintf('%s/TLEIC_year%i_rand%i.mat',foldername,cfgMC.time0.Year,rngseed);    % filename to save information to\n    cfgMC.filename_save = filename_save;\n    cfgMC.n_save_checkpoint = inf; % cfgMC.saveMSnTimesteps * 10; % save the results every n_save_checkpoint step\n    end\n</code></pre> <pre><code>    function [nS,nD,nN,nB,deorbitlist_r]=main_mc(MCconfig,RNGseed)\n</code></pre>"},{"location":"guide/","title":"Quick-Start Guide","text":"<p>MOCAT Monte Carlo single run example:</p> <p>```Py linenums=\"1\"</p> <pre><code>addpath(genpath(pwd)); % just temporally include all subfolders\n\nICfile = '2020.mat'\n\nseed = 1; % random number generation base\n\ndisp('MC configuration starting...');\ncfgMC = setup_MCconfig(seed,ICfile);\nfprintf('Seed %i\\n', seed);\n\nfprintf('Initial Population:  %i sats\\n', size(cfgMC.mat_sats,1));\nfprintf('Launches per year: %i\\n', size(cfgMC.repeatLaunches,1));\ndisp('Starting main_mc...');\n\n[nS,nD,nN,nB]=main_mc(cfgMC,seed);\n\n% developing functionality\nLRCI(idx) = nS/(nS+nD+nN+nB);\n</code></pre> <p>``` </p>"},{"location":"nolaunchexample/","title":"No Launch Scenario","text":"<p>Changes made to setup_MCconfig file:</p> <pre><code>    % SET PROPAGATION TIMES\n    t0_prop = 0;                                    % initial PROPAGATION time [min]\n    nyears = 10;                                    % length of PROPAGATION [years]\n\n    % LAUNCHES\n    Simulation = 'TLE';                     % 'TLE'\n    launch_model = 'no_launch';             % random, matsat, no_launch, data, Somma      \n    % 0: random launch via poisson distribution (see initSim below)\n    % 1: repeat launches between years X and Y (ESA style launch)\n\n    cfgMC.launchRepeatYrs = [2018,2022];    % Min/max year of obj to repeatedly launch (inclusive)\n</code></pre>"}]}